"use strict";(self.webpackChunkmomento_docs=self.webpackChunkmomento_docs||[]).push([[2243],{5718:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>h,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var a=n(4848),i=n(8453),o=n(2480);const r={sidebar_position:2,title:"API Caching Pattern",sidebar_label:"API Caching",description:"Learn how to use Momento Cache to boost performance of applications using the WolframAlpha API",keywords:["cache","momento","read-aside","wolframalpha","api caching","api"]},s="Use Momento Cache to cache results from an API",c={id:"cache/patterns/api-caching",title:"API Caching Pattern",description:"Learn how to use Momento Cache to boost performance of applications using the WolframAlpha API",source:"@site/docs/cache/patterns/api-caching.md",sourceDirName:"cache/patterns",slug:"/cache/patterns/api-caching",permalink:"/cache/patterns/api-caching",draft:!1,unlisted:!1,editUrl:"https://github.com/momentohq/public-dev-docs/tree/main/docs/cache/patterns/api-caching.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"API Caching Pattern",sidebar_label:"API Caching",description:"Learn how to use Momento Cache to boost performance of applications using the WolframAlpha API",keywords:["cache","momento","read-aside","wolframalpha","api caching","api"]},sidebar:"tutorialSidebar",previous:{title:"Database Caching",permalink:"/cache/patterns/database-caching"},next:{title:"Develop",permalink:"/cache/develop/"}},h={},l=[{value:"Getting Started",id:"getting-started",level:2},{value:"See More",id:"see-more",level:2}];function p(e){const t={a:"a",code:"code",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h1,{id:"use-momento-cache-to-cache-results-from-an-api",children:"Use Momento Cache to cache results from an API"}),"\n",(0,a.jsx)(t.p,{children:"Remote calls to an API can be slow and expensive. Depending on the access pattern, it can be desirable to store results in a cache to improve your application's latency and availability."}),"\n",(0,a.jsxs)(t.p,{children:["With ",(0,a.jsx)(t.a,{href:"../",children:"Momento Cache"}),", you can easily cache results from an API in a highly-available and scalable remote cache."]}),"\n",(0,a.jsx)(t.h2,{id:"getting-started",children:"Getting Started"}),"\n",(0,a.jsx)(t.p,{children:"In this example we will build an application that can give us a string description of the current weather of the given place. We will use the WolframAlpha API in this example to show you how we can cache the results of an API."}),"\n",(0,a.jsx)(t.p,{children:"Weather data is relatively static over short periods, making it an ideal candidate for caching. Additionally the WolframAlpha API can be slow to respond due to its computational model. You can expect latency of around 700ms for the WolframAlpha API versus the latency of less than 5ms for the Momento GET API."}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://console.gomomento.com/caches/create",children:"Create a cache in the Momento console"})}),"\n",(0,a.jsx)(t.li,{children:(0,a.jsx)(t.a,{href:"https://developer.wolframalpha.com",children:"Obtain an API Key (AppId) from WolframAlpha"})}),"\n",(0,a.jsxs)(t.li,{children:["To call the WolframAlpha API to retrieve a string description of the current weather, you can create a client, ",(0,a.jsx)(t.code,{children:"WeatherDescriptionClient"}),", that does the following:"]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"import {City, WeatherDescriptionClient} from './weather-description-client';\n\n// We list only selected cities for brevity.\nexport enum City {\n  NewYork,\n  LosAngeles,\n  Chicago,\n  Houston,\n  Phoenix,\n}\n\nexport interface WeatherDescriptionClient {\n  getWeatherDescription(city: City): Promise<string>;\n}\n\nexport class WolframWeatherDescriptionClient\n  implements WeatherDescriptionClient\n{\n  secretAppId: string;\n  constructor() {\n    const envSecretAppId = process.env['WOLFRAM_APP_ID'];\n    if (!envSecretAppId) {\n      throw new Error('Must provide WOLFRAM_APP_ID env variable');\n    }\n    this.secretAppId = envSecretAppId;\n  }\n\n  async getWeatherDescription(city: City): Promise<string> {\n    const cityName = City[city];\n    const url = `https://api.wolframalpha.com/v1/result?appid=${this.secretAppId}&i=Weather for ${cityName}`;\n    const response = await fetch(url);\n    if (response.ok) {\n      return await response.text();\n    } else {\n      const errorString = await response.text();\n      throw new Error(`Wolfram returned an error: ${errorString}`);\n    }\n  }\n}\n"})}),"\n",(0,a.jsxs)(t.ol,{start:"4",children:["\n",(0,a.jsxs)(t.li,{children:["Recall that this scenario is well-suited for caching. We can cache the results using ",(0,a.jsx)(t.a,{href:"../../sdks",children:"Momento JavaScript SDK"}),".\nFor code reusability, we use ",(0,a.jsx)(t.a,{href:"https://en.wikipedia.org/wiki/Decorator_pattern",children:"the Decorator pattern"})," to wrap ",(0,a.jsx)(t.code,{children:"CachingWeatherDescriptionClient"})," around an abstract ",(0,a.jsx)(t.code,{children:"WeatherDescriptionClient"})," that we have created in an earlier step. Note that this requires no code-change to the existing ",(0,a.jsx)(t.code,{children:"WolframWeatherDescriptionClient"}),"."]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"import {CacheClient, CacheGet} from '@gomomento/sdk';\n\n// This is the name of the distributed cache that we will use\n// to store weather results for different cities.\n// This cache must be created beforehand.\nconst CACHE_NAME = 'weather-descriptions';\n\n// Weather data is highly cacheable since it is not likely to change rapidly.\n// Here we can configure the TTL for how long we want to cache the weather data for.\nconst WEATHER_CACHE_TTL_SECONDS = 300;\n\n// This is an inline distributed cache.\n// Results are served from the cache whenever possible.\n// On a cache miss, the actual service is called, then\n// the result will be populated into the cache automatically.\nexport class CachingWeatherDescriptionClient\n  implements WeatherDescriptionClient\n{\n  delegate: WeatherDescriptionClient;\n  momentoCacheClient: IMomentoCache;\n\n  constructor(\n    delegate: WeatherDescriptionClient,\n    momentoCacheClient: CacheClient\n  ) {\n    this.delegate = delegate;\n    this.momentoCacheClient = momentoCacheClient.cache(CACHE_NAME);\n  }\n\n  // With our Momento Cache, we need to establish a keyspace to make sure\n  // that two different cities do not map to the same key.\n  // In this demo we simply use the string name of the city.\n  cacheKey(city: City): string {\n    const cityName = City[city];\n    return cityName;\n  }\n\n  // Asynchronously stores the result into cache to not impact\n  // the critical path of the application.\n  // For more comprehensive error handling,\n  // you may add .then() method to Promise<CacheSet.Response>.\n  populateCacheWithResult(city: City, result: string) {\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    this.momentoCacheClient.set(this.cacheKey(city), result, {\n      ttl: WEATHER_CACHE_TTL_SECONDS,\n    });\n  }\n\n  async getWeatherDescription(city: City): Promise<string> {\n    const getResponse = await this.momentoCacheClient.get(this.cacheKey(city));\n\n    const weatherDescription = getResponse.value();\n    if (!weatherDescription) {\n      // If the weather is not in the cache, call actual client,\n      // and populate the cache.\n      const response = await this.delegate.getWeatherDescription(city);\n      this.populateCacheWithResult(city, response);\n      return response;\n    }\n\n    return weatherDescription;\n  }\n}\n"})}),"\n",(0,a.jsxs)(t.ol,{start:"5",children:["\n",(0,a.jsxs)(t.li,{children:["By using the Decorator Pattern, we can easily compose ",(0,a.jsx)(t.code,{children:"CachingWeatherDescriptionClient"})," and ",(0,a.jsx)(t.code,{children:"WolframWeatherDescriptionClient"})," together to create a new client that does read-aside caching, i.e. if a result is in the cache, return the result, otherwise fallback to retrieving the result from the remote API.\nThis is an example code that leverages Momento Cache to cache results of the WolframAlpha API into a remote cache:"]}),"\n"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-typescript",children:"import {CacheClient, CredentialProvider} from '@gomomento/sdk';\n\nasync function main() {\n  const momentoClient = await CacheClient.create({\n    credentialProvider: CredentialProvider.fromEnvVar('MOMENTO_API_KEY'),\n    defaultTtlSeconds: 60,\n  });\n  const wolframWeatherClient = new WolframWeatherDescriptionClient();\n  const cachingWeatherClient = new CachingWeatherDescriptionClient(\n    wolframWeatherClient,\n    momentoClient\n  );\n\n  const response = await cachingWeatherClient.getWeatherDescription(\n    City.Phoenix\n  );\n\n  // As of this writing the weather in Arizona is:\n  // \"The weather in Phoenix, Arizona, currently includes no precipitation with clear skies, a wind speed of 9 miles per hour and a temperature of 78 degrees Fahrenheit\"\n  console.log(`${response}`);\n}\n\n"})}),"\n",(0,a.jsx)(t.p,{children:"That is it! This is a simple example of how to cache an API result. Here are a few more things that you can tweak further to adapt Momento Cache to your exact use-case:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsx)(t.li,{children:"You can further leverage the Decorator pattern to add more functionality without modifying the existing code. For example you can add a Decorator for metrics/logging so that you get instrumentation on error rates and cache hit rates."}),"\n",(0,a.jsx)(t.li,{children:"TTL (how long items get to live in a cache) can be adjusted on a per-item basis to fit your use-case. For example, in our earlier code, we could've made the TTLs different for different cities."}),"\n",(0,a.jsx)(t.li,{children:"You can cache more than just Strings into Momento Cache. In our earlier example we cache strings but Momento Cache can also accept byte arrays. This allows you to cache an arbitrary object in your application, provided that you implement your own custom serialization/deserialization."}),"\n"]}),"\n",(0,a.jsx)(t.h2,{id:"see-more",children:"See More"}),"\n","\n",(0,a.jsxs)("div",{style:{display:"flex",flexDirection:"row",flexWrap:"wrap",gap:"20px",marginBottom:"20px"},children:[(0,a.jsx)(o.A,{title:"6 common caching strategies",link:"https://www.gomomento.com/blog/6-common-caching-design-patterns-to-execute-your-caching-strategy",description:"Learn more about other types of caching strategies"}),(0,a.jsx)(o.A,{title:"Using Momento to cache chatbot calls",link:"https://www.gomomento.com/resources/case-studies/cydas-people-takes-momento-cache-to-prod-for-their-chatgpt-ai-powered-chatbot-in-just-two-hours",description:"See how CYDAS used Momento to cache calls to LangChain to build a chatbot"})]})]})}function d(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},2480:(e,t,n)=>{n.d(t,{A:()=>l});n(6540);const a="card_Yy4i",i="cardLink_tPnZ",o="cardContent_l93Q",r="cardTitle_gz5m",s="cardDescription_RQFX",c="cardBody_MLn8";var h=n(4848);const l=e=>{let{title:t,description:n,link:l,icon:p,variation:d="normal"}=e,m="",u="";if("dense"===d.toLowerCase())m="0",u="15em";return(0,h.jsx)("div",{className:a,style:{width:u},children:(0,h.jsx)("a",{href:l,target:"_blank",className:i,children:(0,h.jsxs)("div",{className:c,children:[p&&(0,h.jsx)("img",{src:p,height:"32px",width:"32px"}),(0,h.jsxs)("div",{className:o,children:[(0,h.jsx)("h3",{className:r,children:t}),(0,h.jsx)("p",{className:s,style:{marginBottom:m},children:n})]})]})})})}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>s});var a=n(6540);const i={},o=a.createContext(i);function r(e){const t=a.useContext(o);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),a.createElement(o.Provider,{value:t},e.children)}}}]);
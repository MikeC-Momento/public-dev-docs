"use strict";(self.webpackChunkmomento_docs=self.webpackChunkmomento_docs||[]).push([[9506],{7740:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>h,contentTitle:()=>l,default:()=>m,frontMatter:()=>c,metadata:()=>d,toc:()=>p});var i=s(4848),t=s(8453),a=s(1470),o=s(9365),r=s(2480);const c={sidebar_position:10,title:"Instant Messaging Pattern",sidebar_label:"Instant messaging",description:"Learn best practices for building instant messaging with Momento Cache and Topics.",keywords:["topics","development patterns","momento","chat","instant messaging","enterprise patterns"]},l="Use Momento Cache and Topics to build instant messaging",d={id:"topics/patterns/instant-messaging",title:"Instant Messaging Pattern",description:"Learn best practices for building instant messaging with Momento Cache and Topics.",source:"@site/docs/topics/patterns/instant-messaging.mdx",sourceDirName:"topics/patterns",slug:"/topics/patterns/instant-messaging",permalink:"/topics/patterns/instant-messaging",draft:!1,unlisted:!1,editUrl:"https://github.com/momentohq/public-dev-docs/tree/main/docs/topics/patterns/instant-messaging.mdx",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10,title:"Instant Messaging Pattern",sidebar_label:"Instant messaging",description:"Learn best practices for building instant messaging with Momento Cache and Topics.",keywords:["topics","development patterns","momento","chat","instant messaging","enterprise patterns"]},sidebar:"topicsSidebar",previous:{title:"Patterns"},next:{title:"Running background tasks",permalink:"/topics/patterns/running-background-tasks"}},h={},p=[{value:"Architecture",id:"architecture",level:2},{value:"Components",id:"components",level:2},{value:"Message storage",id:"message-storage",level:3},{value:"Lists",id:"lists",level:4},{value:"Delivery",id:"delivery",level:3},{value:"Publishing a message",id:"publishing-a-message",level:4},{value:"Subscribing to a topic",id:"subscribing-to-a-topic",level:4},{value:"Security",id:"security",level:2},{value:"Client-side only",id:"client-side-only",level:3},{value:"Server-side and client-side",id:"server-side-and-client-side",level:3},{value:"Learn more",id:"learn-more",level:2}];function u(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"use-momento-cache-and-topics-to-build-instant-messaging",children:"Use Momento Cache and Topics to build instant messaging"}),"\n",(0,i.jsxs)(n.p,{children:["Instant messaging is a must-have feature in many applications. Communicating seamlessly in one-to-one, one-to-many, and many-to-many conversations is often thought of as a necessary component of an application. With Momento Cache and Topics, you can build instant messaging into your application without any backend infrastructure. Using the ",(0,i.jsx)(n.a,{href:"../../sdks/web",children:"Momento web SDK"}),", you can access your cache data and publish and subscribe to messages directly in your browser."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsxs)(n.p,{children:["This pattern uses ",(0,i.jsx)(n.strong,{children:"Momento Cache"})," to store historical messages and ",(0,i.jsx)(n.strong,{children:"Momento Topics"})," to facilitate real-time communication between instant messaging participants."]})}),"\n",(0,i.jsx)(n.h2,{id:"architecture",children:"Architecture"}),"\n",(0,i.jsx)(n.p,{children:"Building instant messaging on Momento can be done entirely client-side, meaning in your user interface. Browsers, iPhone apps, and Android apps all have the capability to access resources in Momento directly."}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsx)(n.img,{alt:"Diagram of client applications communicating directly via Momento",src:s(5156).A+"",width:"1299",height:"253"})}),"\n",(0,i.jsxs)(n.p,{children:["In the diagram above, messages are being loaded from a ",(0,i.jsx)(n.a,{href:"../../cache/develop/basics/datatypes#lists",children:"list"})," when a new user joins the chat. Users subscribe to a chatroom-specific topic to recieve messages in real-time while they are active in the chat. As messages are sent, they are added directly to the list by the sender."]}),"\n",(0,i.jsx)(n.h2,{id:"components",children:"Components"}),"\n",(0,i.jsx)(n.p,{children:"Instant messaging is separated into two parts:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Message storage"}),"\n",(0,i.jsx)(n.li,{children:"Delivery"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"These core components allow users to join your chat at any time and view the message history and enable them to receive new messages in real time."}),"\n",(0,i.jsx)(n.h3,{id:"message-storage",children:"Message storage"}),"\n",(0,i.jsxs)(n.p,{children:["Most instant messaging platforms store messages to allow users to view the conversation history if messages were sent prior to their arrival. Part of the startup tasks when entering a chat room is loading said history and displaying it on screen. This can easily be done with a Momento ",(0,i.jsx)(n.strong,{children:"list"})," cache item."]}),"\n",(0,i.jsx)(n.h4,{id:"lists",children:"Lists"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.a,{href:"../../cache/develop/basics/datatypes#lists",children:"list"})," is a collection data type that stores an ordered array of elements. You can push elements to either the front or back of a list and you can add multiple entries at one time. A list is a great data type for instant messaging because it stores messages in the order they were sent. When users join an instant messaging session, you can quickly fetch the entire chat history with a single ",(0,i.jsx)(n.a,{href:"../../cache/develop/api-reference/list-collections#listfetch",children:"listFetch API call"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Elements in a list do not need to be unique. You can push the same message into a list over and over again and it will be added every time. Lists are a good choice for instant messaging for the following use cases:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Fetching messages N at a time"}),"\n",(0,i.jsx)(n.li,{children:"Adding multiple messages at once"}),"\n",(0,i.jsx)(n.li,{children:"Maintaining a chat history of fixed length, i.e. the last 100 messages"}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"When using a list, you have a number of array manipulation functions, allowing you to automatically truncate message history if it gets too long or remove specific elements for things like content moderation."}),"\n",(0,i.jsx)(n.h3,{id:"delivery",children:"Delivery"}),"\n",(0,i.jsxs)(n.p,{children:["Technically, message storage is not a required component for instant messaging. In theory you could have a messaging system that only showed the messages that were sent while a user is connected. Messages could be stored in memory in the client and you'd be done. In contrast, message delivery is a mandatory part of instant messaging. Getting the message from the sender to all recipients with minimal latency is the core of this pattern. To do this, we use ",(0,i.jsx)(n.a,{href:"https://www.gomomento.com/platform/topics",children:"Momento Topics"}),"."]}),"\n",(0,i.jsxs)(n.p,{children:["Momento Topics is a low-latency pub/sub service that connects clients together, clients to servers, servers to clients, and servers to servers. Think WebSockets but ",(0,i.jsx)(n.em,{children:"way better"}),". When you publish a message to a topic, Momento will broadcast to all subscribers of the topic, providing fan-out capability or 1 to 1, depending on your use case."]}),"\n",(0,i.jsxs)(n.p,{children:["For instant messaging, the sender will ",(0,i.jsx)(n.em,{children:"publish"})," a message to a topic. The recipients of the message, be it one or many depending on your use case, will be ",(0,i.jsx)(n.em,{children:"subscribers"}),". Momento Topics will deliver the published message to the subscribers in real-time, providing for the instant messaging experience we're looking for!"]}),"\n",(0,i.jsx)(n.admonition,{type:"tip",children:(0,i.jsxs)(n.p,{children:["Momento Topics provides you with flexible, dynamic topics that are not defined as resources in your infrastructure. The recommended way to build instant messaging is to ",(0,i.jsx)(n.em,{children:"use the chat room or session identifier as the topic name"}),". This provides flexible and dedicated topics for chat use cases."]})}),"\n",(0,i.jsx)(n.h4,{id:"publishing-a-message",children:"Publishing a message"}),"\n",(0,i.jsx)(n.p,{children:"To publish a message, all you need is a single command:"}),"\n",(0,i.jsxs)(a.A,{children:[(0,i.jsx)(o.A,{value:"node",label:"Node.js",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"await topics.publish('message-namespace', sessionId, 'Hello world!');\n"})})}),(0,i.jsx)(o.A,{value:"python",label:"Python",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'topics.publish("message-namespace", sessionId, "Hello world!")\n'})})}),(0,i.jsx)(o.A,{value:"go",label:"Go",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:'_, err := topics.Publish(ctx, &momento.TopicPublishRequest{\n  CacheName: momento.String("message-namespace"),\n  TopicName: sessionId,\n  Value: momento.String("Hello world!")\n})\n'})})}),(0,i.jsx)(o.A,{value:"java",label:"Java",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'final TopicPublishResponse response = topics.publish("message-namespace", sessionId, "Hello world!").join();\n'})})}),(0,i.jsx)(o.A,{value:"dotnet",label:".NET",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'var response = await topics.PublishAsync("message-namespace", sessionId, "Hello world!");\n'})})})]}),"\n",(0,i.jsx)(n.h4,{id:"subscribing-to-a-topic",children:"Subscribing to a topic"}),"\n",(0,i.jsx)(n.p,{children:"Subscribing for messages tells Momento whenever something is published to a specific topic, deliver it here and run a specific event handler function. You can subscribe 1 or thousands (or more!) of clients to an individual topic."}),"\n",(0,i.jsxs)(a.A,{children:[(0,i.jsx)(o.A,{value:"node",label:"Node.js",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:"const subscription = await topics.subscribe('message-namespace', sessionId, {\n  onItem: (data) => processMessage(data.value(), data.tokenId())\n});\n"})})}),(0,i.jsx)(o.A,{value:"python",label:"Python",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'with TopicClient(TopicConfigurations.Default.v1(), _AUTH_PROVIDER) as client:\n  subscription = client.subscribe("cache", "my_topic")\n  match subscription:\n    case TopicSubscribe.Error():\n      raise Exception("Subscription error: ", subscription.message)\n    case TopicSubscribe.Subscription():\n      for item in subscription:\n        match item:\n          case TopicSubscriptionItem.Text():\n            print(item.value)\n          case TopicSubscriptionItem.Binary():\n            print(item.value!r)\n'})})}),(0,i.jsx)(o.A,{value:"go",label:"Go",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-go",children:"subscription, err := topicClient.Subscribe(ctx, &momento.TopicSubscribeRequest{\n  CacheName: cacheName,\n  TopicName: topicName,\n})\nif err != nil {\n  panic(err)\n}\n\ngo func() { pollForMessages(ctx, subscription) }()\ntime.Sleep(time.Second)\n\nfunc pollForMessages(ctx context.Context, subscription momento.TopicSubscription) {\n  for {\n    item, err := subscription.Item(ctx)\n    if err != nil {\n      panic(err)\n    }\n    switch message := item.(type) {\n    case momento.String:\n      fmt.Printf(\"received message as string: '%v'\\n\", message)\n    case momento.Bytes:\n      fmt.Printf(\"received message as bytes: '%v'\\n\", message)\n    }\n  }\n}\n"})})}),(0,i.jsx)(o.A,{value:"java",label:"Java",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'final TopicSubscribeResponse subscribeResponse =\n  topicClient\n    .subscribe(\n      TopicExample.CACHE_NAME,\n      TOPIC_NAME,\n      new ISubscriptionCallbacks() {\n        @Override\n        public void onItem(TopicMessage message) {\n          logger.info("Received message on topic {}: {}", TOPIC_NAME, message.toString());\n        };\n\n        @Override\n        public void onError(Throwable error) {\n          logger.error("Subscription to topic {} failed with error", TOPIC_NAME, error);\n        };\n      };).join();\n'})})}),(0,i.jsx)(o.A,{value:"dotnet",label:".NET",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'var subscriptionTask = Task.Run(async () =>\n{\n  var subscribeResponse = await topicClient.SubscribeAsync(cacheName, TopicName);\n  switch (subscribeResponse)\n  {\n    case TopicSubscribeResponse.Subscription subscription:\n      try {\n        var cancellableSubscription = subscription.WithCancellation(cts.Token);\n        await foreach (var message in cancellableSubscription) {\n          switch (message)\n          {\n            case TopicMessage.Binary:\n              Logger.LogInformation("Received binary message from topic: {binaryData}", Convert.ToBase64String(binary.Value));\n              break;\n            case TopicMessage.Text text:\n              Logger.LogInformation("Received string message from topic: {message}", text.Value);\n              break;\n            case TopicMessage.Error error:\n              Logger.LogInformation("Received error message from topic: {error}", error.Message);\n              cts.Cancel();\n              break;\n          }\n        }\n      } finally {\n        subscription.Dispose();\n      }\n\n      break;\n    case TopicSubscribeResponse.Error error:\n      Logger.LogInformation("Error subscribing to a topic: {error}", error.Message);\n      cts.Cancel();\n      break;\n  }\n});\n'})})})]}),"\n",(0,i.jsx)(n.h2,{id:"security",children:"Security"}),"\n",(0,i.jsxs)(n.p,{children:["Momento provides a ",(0,i.jsx)(n.a,{href:"../develop/authentication/tokens",children:"robust authorization mechanism"})," that limits consumers to specific resources and actions. When building an instant messaging feature, it is incredibly important to take scope into consideration so users do not intercept messages they shouldn't have access to."]}),"\n",(0,i.jsx)(n.p,{children:"The pattern described above uses both cache and topic resources. Following the best practice recommended above by making the chat room match the topic name, we can create policies in a couple of different ways."}),"\n",(0,i.jsx)(n.h3,{id:"client-side-only",children:"Client-side only"}),"\n",(0,i.jsx)(n.p,{children:"It's possible to build instant messaging completely on the client side, meaning directly in the browser or mobile application. The policy below would be used in your clients."}),"\n",(0,i.jsxs)(a.A,{children:[(0,i.jsx)(o.A,{value:"node",label:"Node.js",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'const scope = {\n  permissions: [\n    {\n      role: "readwrite",\n      cache: "instant-messaging",\n      item: {\n        key: chatId\n      }\n    },\n    {\n      role: "publishsubscribe",\n      cache: "instant-messaging",\n      topic: chatId\n    }\n  ]\n};\n\nconst token = await authClient.generateDisposableToken(scope, ExpiresIn.hours(1));\n'})})}),(0,i.jsx)(o.A,{value:"java",label:"Java",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'List<DisposableTokenPermission> permissions = new ArrayList<>();\n  permissions.add(\n      new DisposableToken.CacheItemPermission(\n          CacheRole.ReadWrite, CacheSelector.ByName("instant-messaging"), CacheSelector.ByName(chatId)));\n  permissions.add(\n      new DisposableToken.TopicPermission(\n          TopicRole.PublishSubscribe,\n          CacheSelector.ByName("instant-messaging"),\n          TopicSelector.ByName(chatId)));\n  DisposableTokenScope scope = new DisposableTokenScope(permissions);\n\n  GenerateDisposableTokenResponse response =  authClient.generateDisposableTokenAsync(scope, ExpiresIn.hours(1)).join();\n'})})}),(0,i.jsx)(o.A,{value:"dotnet",label:".NET",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'var scope = new DisposableTokenScope(Permissions: new List<DisposableTokenPermission>\n  {\n      new DisposableToken.CacheItemPermission(\n          CacheRole.ReadWrite,\n          CacheSelector.ByName("instant-messaging"),\n          CacheSelector.ByName(chatid)\n      ),\n      new DisposableToken.TopicPermission(\n          TopicRole.PublishSubscribe,\n          CacheSelector.ByName("instant-messaging"),\n          TopicSelector.ByName(chatid)\n      )\n  });\n\n  var tokenResponse = await client.GenerateDisposableTokenAsync( scope, ExpiresIn.Hours(1));\n'})})})]}),"\n",(0,i.jsx)(n.p,{children:"This policy grants read and write permissions to a specific cache item."}),"\n",(0,i.jsx)(n.p,{children:"It also grants publish and subscribe permissions to a single topic. Consumers will be able to publish messages to and recieve messages from the one topic. Attempting to subscribe to any other topic will result in an authorization error."}),"\n",(0,i.jsx)(n.p,{children:"Note that both the cache item and topic share the same value. This is the recommended best practice and the data from the cache item will not interfere with the messages being published to the topic."}),"\n",(0,i.jsx)(n.p,{children:"Once the policy is created, you pass it to the client and create a token that expires after a set amount of time."}),"\n",(0,i.jsxs)(n.admonition,{type:"info",children:[(0,i.jsx)(n.p,{children:"The tradeoff for a client-side only approach is trust in your front-end. Since this opens write permissions to the client, you must be careful with what you expose in the code. Allowing end users to do write operations requires trust in their usage, since you cannot moderate messages before accepting them. This also takes a distributed approach to storing data instead of centralizing storage in server-side code."}),(0,i.jsx)(n.p,{children:"If that is tolerable for your application, it results in unrivaled time-to-market and minimal complexity in your application."})]}),"\n",(0,i.jsx)(n.h3,{id:"server-side-and-client-side",children:"Server-side and client-side"}),"\n",(0,i.jsx)(n.p,{children:"If you centralize writes in your server-side code, the pattern changes slightly. Raw message input would be submitted through one topic and be picked up by the server code. Any transformations or moderation would be performed before sending it back down to the verified topic. Below is an example of the policy that would be used on the client side following this pattern."}),"\n",(0,i.jsxs)(a.A,{children:[(0,i.jsx)(o.A,{value:"node",label:"Node.js",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'const scope = {\n  permissions: [\n    {\n      role: "read",\n      cache: "instant-messaging",\n      item: {\n        key: chatId\n      }\n    },\n    {\n      role: "publishonly",\n      cache: "instant-messaging",\n      topic: `${chatid}-input`\n    },\n    {\n      role: "subscribeonly",\n      cache: "instant-messaging",\n      topic: chatid\n    },\n  ]\n};\n\nconst token = await authClient.generateDisposableToken(scope, ExpiresIn.hours(1));\n'})})}),(0,i.jsx)(o.A,{value:"java",label:"Java",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-java",children:'List<DisposableTokenPermission> permissions = new ArrayList<>();\n  permissions.add(\n      new DisposableToken.CacheItemPermission(\n          CacheRole.ReadOnly, CacheSelector.ByName("instant-messaging"), CacheSelector.ByName(chatId)));\n  permissions.add(\n      new DisposableToken.TopicPermission(\n          TopicRole.PublishOnly,\n          CacheSelector.ByName("instant-messaging"),\n          TopicSelector.ByName(chatId + "-input")));\n  permissions.add(\n    new DisposableToken.TopicPermission(\n          TopicRole.SubscribeOnly,\n          CacheSelector.ByName("instant-messaging"),\n          TopicSelector.ByName(chatId)));\n\n  DisposableTokenScope scope = new DisposableTokenScope(permissions);\n\n  GenerateDisposableTokenResponse response =  authClient.generateDisposableTokenAsync(scope, ExpiresIn.hours(1)).join();\n'})})}),(0,i.jsx)(o.A,{value:"dotnet",label:".NET",children:(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-csharp",children:'var scope = new DisposableTokenScope(Permissions: new List<DisposableTokenPermission>\n  {\n      new DisposableToken.CacheItemPermission(\n          CacheRole.ReadOnly,\n          CacheSelector.ByName("instant-messaging"),\n          CacheSelector.ByName(chatid)\n      ),\n      new DisposableToken.TopicPermission(\n          TopicRole.PublishOnly,\n          CacheSelector.ByName("instant-messaging"),\n          TopicSelector.ByName($"{chatid}-input")\n      ),\n      new DisposableToken.TopicPermission(\n          TopicRole.SubscribeOnly,\n          CacheSelector.ByName("instant-messaging"),\n          TopicSelector.ByName(chatid)\n      )\n  });\n\n  var tokenResponse = await client.GenerateDisposableTokenAsync( scope, ExpiresIn.Hours(1));\n'})})})]}),"\n",(0,i.jsx)(n.p,{children:"The policy above grants read-only access to the cache item storing the conversation. The write is done server-side after moderation and transformation is complete."}),"\n",(0,i.jsxs)(n.p,{children:["It also grants publish access to the ",(0,i.jsx)(n.code,{children:"{chatid}-input"})," topic. The server code subscribes to this topic, does the moderation, and publishes the final message to the ",(0,i.jsx)(n.code,{children:"{chatid}"})," topic, which the client has subscribe access to."]}),"\n",(0,i.jsx)(n.h2,{id:"learn-more",children:"Learn more"}),"\n",(0,i.jsx)(n.p,{children:"Momento enables fast, secure development of instant messaging in any application. To learn more about Cache and Topics or to get a quick-start on your project, check out some additional resources below."}),"\n",(0,i.jsxs)("div",{style:{display:"flex",flexDirection:"row",flexWrap:"wrap",gap:"20px",marginBottom:"20px"},children:[(0,i.jsx)(r.A,{title:"More about instant messaging",link:"https://www.gomomento.com/solutions/use-cases/chat",description:"Learn more about how to build instant messaging on Momento"}),(0,i.jsx)(r.A,{title:"How to build a multi-language chat app",link:"https://www.gomomento.com/blog/how-to-develop-a-chat-app-with-built-in-moderation",description:"Walk through an app that automatically translates messages to other languages"}),(0,i.jsx)(r.A,{title:"In-game chat case study",link:"https://www.gomomento.com/resources/case-studies/momento-enables-zigzagame-to-go-fully-serverless-and-save-money-in-the-process",description:"See how ZigZaGame used Momento to power their in-game chat"})]})]})}function m(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(u,{...e})}):u(e)}},9365:(e,n,s)=>{s.d(n,{A:()=>o});s(6540);var i=s(4164);const t={tabItem:"tabItem_Ymn6"};var a=s(4848);function o(e){let{children:n,hidden:s,className:o}=e;return(0,a.jsx)("div",{role:"tabpanel",className:(0,i.A)(t.tabItem,o),hidden:s,children:n})}},1470:(e,n,s)=>{s.d(n,{A:()=>w});var i=s(6540),t=s(4164),a=s(3104),o=s(6347),r=s(205),c=s(7485),l=s(1682),d=s(679);function h(e){return i.Children.toArray(e).filter((e=>"\n"!==e)).map((e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}function p(e){const{values:n,children:s}=e;return(0,i.useMemo)((()=>{const e=n??function(e){return h(e).map((e=>{let{props:{value:n,label:s,attributes:i,default:t}}=e;return{value:n,label:s,attributes:i,default:t}}))}(s);return function(e){const n=(0,l.X)(e,((e,n)=>e.value===n.value));if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[n,s])}function u(e){let{value:n,tabValues:s}=e;return s.some((e=>e.value===n))}function m(e){let{queryString:n=!1,groupId:s}=e;const t=(0,o.W6)(),a=function(e){let{queryString:n=!1,groupId:s}=e;if("string"==typeof n)return n;if(!1===n)return null;if(!0===n&&!s)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return s??null}({queryString:n,groupId:s});return[(0,c.aZ)(a),(0,i.useCallback)((e=>{if(!a)return;const n=new URLSearchParams(t.location.search);n.set(a,e),t.replace({...t.location,search:n.toString()})}),[a,t])]}function g(e){const{defaultValue:n,queryString:s=!1,groupId:t}=e,a=p(e),[o,c]=(0,i.useState)((()=>function(e){let{defaultValue:n,tabValues:s}=e;if(0===s.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(n){if(!u({value:n,tabValues:s}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${n}" but none of its children has the corresponding value. Available values are: ${s.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return n}const i=s.find((e=>e.default))??s[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:a}))),[l,h]=m({queryString:s,groupId:t}),[g,b]=function(e){let{groupId:n}=e;const s=function(e){return e?`docusaurus.tab.${e}`:null}(n),[t,a]=(0,d.Dv)(s);return[t,(0,i.useCallback)((e=>{s&&a.set(e)}),[s,a])]}({groupId:t}),y=(()=>{const e=l??g;return u({value:e,tabValues:a})?e:null})();(0,r.A)((()=>{y&&c(y)}),[y]);return{selectedValue:o,selectValue:(0,i.useCallback)((e=>{if(!u({value:e,tabValues:a}))throw new Error(`Can't select invalid tab value=${e}`);c(e),h(e),b(e)}),[h,b,a]),tabValues:a}}var b=s(2303);const y={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};var v=s(4848);function f(e){let{className:n,block:s,selectedValue:i,selectValue:o,tabValues:r}=e;const c=[],{blockElementScrollPositionUntilNextRender:l}=(0,a.a_)(),d=e=>{const n=e.currentTarget,s=c.indexOf(n),t=r[s].value;t!==i&&(l(n),o(t))},h=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const s=c.indexOf(e.currentTarget)+1;n=c[s]??c[0];break}case"ArrowLeft":{const s=c.indexOf(e.currentTarget)-1;n=c[s]??c[c.length-1];break}}n?.focus()};return(0,v.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,t.A)("tabs",{"tabs--block":s},n),children:r.map((e=>{let{value:n,label:s,attributes:a}=e;return(0,v.jsx)("li",{role:"tab",tabIndex:i===n?0:-1,"aria-selected":i===n,ref:e=>c.push(e),onKeyDown:h,onClick:d,...a,className:(0,t.A)("tabs__item",y.tabItem,a?.className,{"tabs__item--active":i===n}),children:s??n},n)}))})}function x(e){let{lazy:n,children:s,selectedValue:t}=e;const a=(Array.isArray(s)?s:[s]).filter(Boolean);if(n){const e=a.find((e=>e.props.value===t));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return(0,v.jsx)("div",{className:"margin-top--md",children:a.map(((e,n)=>(0,i.cloneElement)(e,{key:n,hidden:e.props.value!==t})))})}function j(e){const n=g(e);return(0,v.jsxs)("div",{className:(0,t.A)("tabs-container",y.tabList),children:[(0,v.jsx)(f,{...n,...e}),(0,v.jsx)(x,{...n,...e})]})}function w(e){const n=(0,b.A)();return(0,v.jsx)(j,{...e,children:h(e.children)},String(n))}},2480:(e,n,s)=>{s.d(n,{A:()=>d});s(6540);const i="card_Yy4i",t="cardLink_tPnZ",a="cardContent_l93Q",o="cardTitle_gz5m",r="cardDescription_RQFX",c="cardBody_MLn8";var l=s(4848);const d=e=>{let{title:n,description:s,link:d,icon:h,variation:p="normal"}=e,u="",m="";if("dense"===p.toLowerCase())u="0",m="15em";return(0,l.jsx)("div",{className:i,style:{width:m},children:(0,l.jsx)("a",{href:d,target:"_blank",className:t,children:(0,l.jsxs)("div",{className:c,children:[h&&(0,l.jsx)("img",{src:h,height:"32px",width:"32px"}),(0,l.jsxs)("div",{className:a,children:[(0,l.jsx)("h3",{className:o,children:n}),(0,l.jsx)("p",{className:r,style:{marginBottom:u},children:s})]})]})})})}},5156:(e,n,s)=>{s.d(n,{A:()=>i});const i=s.p+"assets/images/instant-messaging-architecture-7571645aa4337dc413b47eebd12ee1aa.png"},8453:(e,n,s)=>{s.d(n,{R:()=>o,x:()=>r});var i=s(6540);const t={},a=i.createContext(t);function o(e){const n=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);